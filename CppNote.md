# 忘离心的C++学习笔记
## Day1 
- **引用&的定义**
  <p>引用即给<em><strong>变量</em></strong>起别名</p>

      int a = 5，c = 2;
      int &b =a,&d = c;
      b = d;    //含义为将d引用的变量的值赋给b所引用的变量
      cout << a << endl;    //输出2
      
    即定义一个int&型变量b和d，需要注意的是引用<em><strong>从一而终</em></strong>,因而b=d不改变b所引用的变量。

- **“引用的炫酷的写法”**

        int n =4;
        int& SetValue()
        {
            your function code;
            return n; 
        }
        int main()
        {
            SetValue() = 40;
            //可以给n赋值
            cout << n;
            return
        }
        
    采用***引用***作为函数返回值,可以给变量进行赋值。

- **常引用和非常引用的转化**
  
  > 不难想见，可读(const)不一定可写，但可读可写一定可读
  
  因此，非常引用可以用来对常引用初始化，也可以使用转换符(const _Tp &)转换；相反则不行。同理，也延伸到各类变量。

- **const关键字之常量指针和指针常量**

  - 代码展示


        int a = 5,b = 2;
        //定义常量指针(似乎是前一种使用的更多)
        const int* ptr1 = &a;
        int const* ptr2 = &b;
        *ptr1 = 3; 
        *ptr2 = 3;//报错
        ptr1 = &b;
        ptr2 = &a;//不报错


        //定义指针常量
        int* const ptr3 = &a;
        *ptr3 = 4;//不报错
        ptr3 = &b; //报错

  - 记忆上的区分
    >从上面不难看出定义仿佛是符合了<em>“中文定义”</em>,描述指针的<em><strong>*</strong></em>在前则为指针常量，反之则为常量指针，似乎是个巧记的方式。

  - 使用上的区分
    > 区分中比较重要的两点是:<br>
        1. 指向的**地址**能不能改变<br>
        2. 指向的**地址里的存放的值**可变还是不可变<br>


    常量指针<strong>近似于</strong>“指向常量的指针”,对于指针来说，指向的量为常量，即指向的地址里的内容不可修改；然而指针指向的地址却可以改变。**然而需要注意的是**，常量指针可以指向变量，仅仅是在使用指针的时候像个"常量"。<br>
    指针常量则相反，因为本身属于 **“常量”** 的范畴，所以本身需要初始化且始终指向同一个地址，即指向的地址不能改变，而指向地址内的内容则可读可写。
- **常量指针与非常量指针的转化**
    >可读(const)不一定可写，但可读可写一定可读。除非强制转换过了~<br>
    于是乎有代码如下：

            int a = 5;
            const int* ptr1 = &a;
            int *ptr2;
            ptr1 = ptr2; //right
            ptr2 = ptr1; //wrong
            ptr2 = (int *)ptr1;//right!

---
- **new和delete运算符的使用——动态分配内存**
    >
    
    ```C++
    auto P = new T；<br>auto Z = new T[N];
    delete P;
    delete []Z;
    ```
    new运算符分配出sizeof(T)(*N)的内存，并将该内存的起始位置赋值给P。其中T可以为 **"任意类型名"** 在使用完后需要用delete运算符来释放该段内存。

---
  ## Day2
- **内联函数以及inline关键字**
  
  在函数前加入inline关键字即可定义一个内联函数，如:
  ```C++
  inline int Max(int a,int b)
  {
    return (a>b?)a:b
  }
  ```
  >已知函数调用需要时间和空间开销的。在与栈的操作中，函数调用会花费一部分时间。``inline``关键字会将程序中所有调用该函数处全部替换为函数体中的代码块，以此来减少调用时操作栈的时间，而代价则是调用函数处代码可能会变得冗长,导致程序体积可能会增大。即"以空间代价换取时间减小"。
  
  *因此，内联函数一般都是1-5行的小函数。*

- **函数重载**
    >一个或多个函数，名字相同，而参数类型不同(包括位置不同)或者参数的数量不同，互相为不同的函数，这叫做函数重载。

    由此，函数命名变得简单，编译器会自动判断该调用哪一个函数。

- **函数的缺省参数**
  > 为函数添加默认值，也可以增加程序的可扩充性(在增加功能时，可以不用重复修改以往的函数调用语句)


- **类与对象**
   > 结构化程序设计 = 数据结构 + 函数<br>
   面向对象程序设计 = 类 + 类 + ··· + 类

  首先，让我们先给出面向对象程序设计的四个特性

  - 抽象<br>
    将某些事物的**共同**特点（属性）和该事物的行为归纳出来分别形成一个数据结构和一个个函数。
  - 封装<br>
    并且将数据结构和函数二者捆绑在一起，形成 ***"类"*** 。在***类***中，数据结构和函数有着明显的紧密关系。
  - 继承<br>
    ......
  - 多态

- 类的定义
  ```C++
  class yourClassname
  {
    
    ······;
      //此处应有成员变量和成员函数的定义或者声明
  };
  ```
  以上给出了类定义的框架，然而，我们还需要补充其中成员变量和函数的定义。二者定义同外部变量和函数近乎完全一致，但需要说明该成员的私有程度，于是乎，引入`public`,`private`,`protected`关键字。
  > public：表示成员为公有成员，在何处都能访问<br>private：表示成员为私有成员，仅在成员函数(包括**同类不同对象**的成员函数)中可以访问<br>protected：表示成员为保护成员<br>若缺省，则被认为是**私有**成员
  
  于是，我们可以在定义处补充上成员的定义
  ```C++
  class yourclassname
  {
    public:
      int a;
    protected:
      void funcion()
      {
        ;
      }

  };

- 构造函数

  > 构造函数时一类特殊的成员函数，会在对象被生成的时候自动调用，构造函数也不允许有返回值。每个类都有构造函数，即便程序猿没有写，编译器也会自动生成一个“废柴”式啥也不干的构造函数。
  - 构造函数的定义
    > 构造函数与类同名
      ```C++
      class yourclassname
      {
        yourclassname()
        {
          ;
        }//构造函数
        public:
          int a;

      };

---
## Day3

- **复制构造函数**

形如 X::X(X&)或者X::X(const X&)的构造函数叫做复制构造函数。

    
> 复制构造函数也一定存在，编译器也会自动生成。

通过复制构造函数，我们可以这样初始化对象。
```C++
MyClass c1;
auto c2 = MyClass(c1);
```
> 另外，当调用函数时参数存在某对象时，以及对象作为函数返回值时，复制构造函数会被调用。
```C++
void Function(Myclass c1){  ;}

MyClass Function2()
{
  Myclass c3;
  return c3; //此处调用赋值构造函数返回对象

}

int main()
{
  Myclass c2;
  Fuction(c2);//调用复制构造函数予形参赋值
}
